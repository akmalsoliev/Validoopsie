{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>A simple and easy to use Data Validation library for Python.</p> <p> </p>"},{"location":"index.html#validoopsie","title":"Validoopsie","text":"<p>Validoopsie is a remarkably lightweight and user-friendly data validation library for Python. It\u2019s designed to help you easily declare classes and chain validations together, in a style reminiscent of popular DataFrame libraries. This makes it a familiar and intuitive tool for developers who regularly work with dataframes.</p> <p>Thanks to the excellent work by Narwhals, Validoopsie incorporates the \"Bring Your Own DataFrame\" (BYOD) concept. This flexibility allows you to use any DataFrame that Narwhals supports for your data validation tasks. To explore the full range of supported DataFrames, you can visit this link.</p> <p>The syntax of Validoopsie has been thoughtfully crafted to ensure ease of use. Every validation function is encapsulated in its own method, which can be seamlessly linked together. This method-specific design prioritizes simplicity and readability, freeing you from the need to adapt to a new API each time you switch libraries. It allows you to focus on maintaining clean and understandable code.</p> <p>Validoopsie draws significant inspiration from the Great Expectations library. It strives to distill the data validation process into something straightforward and efficient. Whether you're checking data integrity or ensuring compliance with data standards, Validoopsie provides a streamlined yet powerful solution to make these tasks accessible and straightforward.</p>"},{"location":"index.html#installation","title":"Installation","text":"<ul> <li> <p>pip</p> <p><code>pip install Validoopsie</code></p> </li> </ul>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<ul> <li>\ud83d\udcd6 Documentation</li> <li>\ud83d\udea8 Impact Levels in Validoopsie</li> <li>\ud83c\udfaf Threshold Levels in Validoopsie</li> <li>\ud83d\udee0\ufe0f Contribution Guidelines</li> <li>\u2728 Contributing a new Validation to Validoopsie</li> <li>\ud83e\uddd1\u200d\ud83d\udcbb Develop your own custom validation</li> <li>\ud83d\uddc2\ufe0f Validation Catalog</li> </ul> <p>Validoopsie is incredibly easy to use, so much so that you could do it half-asleep. The simplicity of the library is enhanced by the BYOD (Bring Your Own DataFrame) concept, where you merely need to utilize the <code>Validate</code> class and chain your desired validations together. This approach ensures that you can get started with minimal effort and without any unnecessary complexity.</p> <pre><code>import pandas as pd\n\nfrom validoopsie import Validate\n\np_df = pd.DataFrame(\n    {\n        \"name\": [\"John\", \"Doe\", \"Jane\"],\n        \"target_name\": [\"John\", \"Doe\", \"Jane\"],\n        \"last_name\": [\"Smith\", \"Smith\", \"Smith\"],\n        \"age\": [25, 30, 35],\n    },\n)\n\n# `vd` stands for Validate Data\nvd = Validate(p_df)\nvd.EqualityValidation.PairColumnEquality(\n    column=\"name\",\n    target_column=\"age\",\n    impact=\"high\",\n).UniqueValidation.ColumnUniqueValuesToBeInList(\n    column=\"last_name\",\n    values=[\"Smith\"],\n).ValuesValidation.ColumnValuesToBeBetween(\n    \"age\",\n    20,\n    40,\n)\n\nvd.results\n</code></pre> OUTPUT <pre><code>{\n  \"Summary\": {\n    \"passed\": false,\n    \"validations\": [\n      \"PairColumnEquality_name\",\n      \"ColumnUniqueValuesToBeInList_last_name\"\n    ]\n  },\n  \"PairColumnEquality_name\": {\n    \"validation\": \"PairColumnEquality\",\n    \"impact\": \"low\",\n    \"timestamp\": \"2025-01-03T22:28:02.497324+01:00\",\n    \"column\": \"name\",\n    \"result\": {\n      \"status\": \"Fail\",\n      \"threshold pass\": false,\n      \"message\": \"The column 'name' is not equal to the column'age'.\",\n      \"failing items\": [\n        \"Doe - column name - column age - 30\",\n        \"Jane - column name - column age - 35\",\n        \"John - column name - column age - 25\"\n      ],\n      \"failed number\": 3,\n      \"frame row number\": 3,\n      \"threshold\": 0.0,\n      \"failed percentage\": 1.0\n    }\n  },\n  \"ColumnUniqueValuesToBeInList_last_name\": {\n    \"validation\": \"ColumnUniqueValuesToBeInList\",\n    \"impact\": \"low\",\n    \"timestamp\": \"2025-01-03T22:28:02.499192+01:00\",\n    \"column\": \"last_name\",\n    \"result\": {\n      \"status\": \"Success\",\n      \"threshold pass\": true,\n      \"message\": \"All items passed the validation.\",\n      \"frame row number\": 3,\n      \"threshold\": 0.0\n    }\n  }\n}\n</code></pre> <p>To ensure that all your validations have been correctly executed and to handle any potential errors that may arise during the validation process, you can use the <code>validate</code> method. However, it's important to note that errors will only be raised if the <code>impact</code> level is set to <code>high</code>. Without this setting, potential issues may not trigger an error message.</p> <p>NOTE: Raised error is a custom <code>ValueError</code>.</p> <pre><code>import pandas as pd\n\nfrom validoopsie import Validate\n\np_df = pd.DataFrame(\n    {\n        \"name\": [\"John\", \"Doe\", \"Jane\"],\n        \"target_name\": [\"John\", \"Doe\", \"Jane\"],\n        \"last_name\": [\"Smith\", \"Smith\", \"Smith\"],\n        \"age\": [25, 30, 35],\n    },\n)\n\n# `vd` stands for Validate Data\nvd = Validate(p_df)\nvd.EqualityValidation.PairColumnEquality(\n    column=\"name\",\n    target_column=\"age\",\n    impact=\"high\",\n).UniqueValidation.ColumnUniqueValuesToBeInList(\n    column=\"last_name\",\n    values=[\"Smith\"],\n).ValuesValidation.ColumnValuesToBeBetween(\n    \"age\",\n    20,\n    40,\n).validate()\n</code></pre> <p>Thanks to loguru output will provide a very condenced information on validations and their status in a colorful way.</p> <p> </p>"},{"location":"index.html#license","title":"License","text":"<p>MIT \u00a9 Validoopsie</p> <p>Original Creator - Akmal Soliev</p>"},{"location":"impact_levels.html","title":"Impact Levels in Validoopsie","text":"<p>Validoopsie uses impact levels to determine how validation failures should be handled. Properly setting the impact level helps control the behavior of your data validation pipeline.</p>"},{"location":"impact_levels.html#available-impact-levels","title":"Available Impact Levels","text":"<p>Validoopsie supports three impact levels:</p> Level Description Behavior <code>\"low\"</code> Minor validation issues that don't significantly affect data quality Records failures in results but doesn't interrupt processing <code>\"medium\"</code> Moderate validation issues that may affect data quality Records failures in results but doesn't interrupt processing <code>\"high\"</code> Critical validation issues that severely affect data quality Raises a <code>ValueError</code> exception when <code>.validate()</code> is called"},{"location":"impact_levels.html#how-to-set-impact-levels","title":"How to Set Impact Levels","text":"<p>Impact levels can be set on any validation:</p> <pre><code>from validoopsie import Validate\nimport pandas as pd\n\ndf = pd.DataFrame({\n    \"id\": [1, 2, 3, 4, 5],\n    \"value\": [10, 20, 30, 200, 40]\n})\n\nvalidator = Validate(df)\n\n# Low impact - will be recorded but won't raise exceptions\nvalidator.ValuesValidation.ColumnValuesToBeBetween(\n    column=\"value\", \n    min_value=0, \n    max_value=100,\n    impact=\"low\"  # This is the default if not specified\n)\n\n# Medium impact - generally used for important but not critical validations\nvalidator.TypeValidation.TypeCheck(\n    column=\"id\",\n    type_name=\"int64\",\n    impact=\"medium\"\n)\n\n# High impact - will raise an exception when validate() is called\nvalidator.NullValidation.ColumnNotBeNull(\n    column=\"id\",\n    impact=\"high\"  # This will cause validate() to raise an exception if nulls are found\n)\n\n# This will raise an exception if any high-impact validations fail\ntry:\n    validator.validate()\nexcept ValueError as e:\n    print(f\"Validation failed: {e}\")\n</code></pre>"},{"location":"impact_levels.html#when-to-use-each-impact-level","title":"When to Use Each Impact Level","text":"<ul> <li> <p>Low: Use for informational validations or when failures can be tolerated</p> <ul> <li>Example: Checking if string values follow a preferred format</li> <li>Example: Verifying that numerical values fall within suggested (but not required) ranges</li> </ul> </li> <li> <p>Medium: Use for important validations where failures should be highlighted</p> <ul> <li>Example: Checking if dates fall within an expected range</li> <li>Example: Verifying that categorical values belong to an expected set</li> </ul> </li> <li> <p>High: Use for critical validations where failures should interrupt processing</p> <ul> <li>Example: Ensuring primary key columns don't contain null values</li> <li>Example: Verifying that required fields are present</li> <li>Example: Checking data integrity constraints that must be satisfied</li> </ul> </li> </ul>"},{"location":"impact_levels.html#default-impact-level","title":"Default Impact Level","text":"<p>If not specified, all validations default to an impact level of <code>\"low\"</code>.</p>"},{"location":"threshold_levels.html","title":"Threshold Levels in Validoopsie","text":"<p>Validoopsie uses threshold arguments to specify the acceptable failure rate before a validation fails. This allows for more flexible validation rules that can tolerate a certain percentage of exceptions.</p>"},{"location":"threshold_levels.html#understanding-thresholds","title":"Understanding Thresholds","text":"<p>Thresholds in Validoopsie represent the maximum allowable percentage of records that can fail validation:</p> Threshold Description Behavior <code>0.0</code> No failures allowed (default) Validation fails if any records don't meet criteria <code>0.1</code> 10% failure tolerance Validation passes if 90% or more records meet criteria <code>0.5</code> 50% failure tolerance Validation passes if at least half of records meet criteria <code>1.0</code> 100% failure tolerance Validation always passes regardless of failures"},{"location":"threshold_levels.html#how-to-set-thresholds","title":"How to Set Thresholds","text":"<p>Thresholds can be set on any validation:</p> <pre><code>from validoopsie import Validate\nimport pandas as pd\n\ndf = pd.DataFrame({\n    \"id\": [1, 2, 3, 4, 5],\n    \"value\": [10, 20, 30, 200, 40]\n})\n\nvalidator = Validate(df)\n\n# No tolerance - fails if any values are outside range\nvalidator.ValuesValidation.ColumnValuesToBeBetween(\n    column=\"value\", \n    min_value=0, \n    max_value=100,\n    threshold=0.0  # This is the default if not specified\n)\n\n# 20% tolerance - passes if at least 80% of values are within range\nvalidator.ValuesValidation.ColumnValuesToBeBetween(\n    column=\"value\", \n    min_value=0, \n    max_value=100,\n    threshold=0.2\n)\n\n# Combine with impact levels for complete validation control\nvalidator.StringValidation.PatternMatch(\n    column=\"email\",\n    pattern=r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\",\n    threshold=0.05,  # Allow 5% of emails to be invalid\n    impact=\"medium\"  # Record failures but don't interrupt processing\n)\n</code></pre>"},{"location":"threshold_levels.html#when-to-use-thresholds","title":"When to Use Thresholds","text":"<ul> <li> <p>Zero Threshold (0.0): Use for strict validations where no exceptions are allowed</p> <ul> <li>Example: Primary key uniqueness</li> <li>Example: Required fields that must be present</li> </ul> </li> <li> <p>Low Threshold (&lt; 0.1): Use for validations that should generally pass but can tolerate rare exceptions</p> <ul> <li>Example: Email format validation that might have a few legacy exceptions</li> <li>Example: Date format validation with occasional special cases</li> </ul> </li> <li> <p>Medium Threshold (0.1 - 0.5): Use when a significant portion of data might legitimately fail validation</p> <ul> <li>Example: Missing values in optional fields</li> <li>Example: Pattern matching for fields with multiple valid formats</li> </ul> </li> <li> <p>High Threshold (&gt; 0.5): Use rarely, typically for informational validations</p> <ul> <li>Example: Checking if most records follow a new standard that's being gradually implemented</li> <li>Example: Monitoring the adoption rate of new data formats</li> </ul> </li> </ul>"},{"location":"threshold_levels.html#default-threshold","title":"Default Threshold","text":"<p>If not specified, all validations default to a threshold of <code>0.0</code> (no failures allowed).</p>"},{"location":"contributing/CONTRIBUTING.html","title":"Contribution Guidelines","text":"<p>Thank you for considering contributing to Validoopsie! The idea of one spending their time on contribution to this project is wild for me, so I appreciate every minute you spend on it.</p>"},{"location":"contributing/CONTRIBUTING.html#how-to-contribute","title":"How to Contribute","text":"<ol> <li> <p>Fork the repository on GitHub and clone your fork to your local machine:     <pre><code>git clone https://github.com/your-username/Validoopsie.git\n</code></pre></p> </li> <li> <p>Use the Makefile to set up the development environment:     <pre><code>make setup\n</code></pre></p> </li> </ol> <p>This will create a virtual environment and install all dependencies.</p> <p>Alternatively, you can install dependencies manually:     <pre><code>uv venv\nuv sync --all-groups\n</code></pre></p> <ol> <li>Create a new branch for your feature or bugfix:     <pre><code>git checkout -b my-feature-branch\n</code></pre></li> <li>Make your changes in the new branch.</li> <li>Run tests and linters to ensure quality:     <pre><code># Run all tests and linters\nmake all\n\n# Or run them separately\nmake lint\nmake test\n</code></pre></li> <li>Commit your changes with a descriptive commit message:     <pre><code>git commit -m \"Add feature X\"\n</code></pre></li> <li>Push your branch to your fork on GitHub:     <pre><code>git push origin my-feature-branch\n</code></pre></li> <li>Open a pull request on the main repository.</li> </ol>"},{"location":"contributing/CONTRIBUTING.html#submitting-changes","title":"Submitting Changes","text":"<ol> <li>Ensure that your code follows the project's Style-guide (basically ruff).</li> <li>Ensure that all tests pass.</li> <li>Open a pull request with a clear title and description of your changes.</li> <li>Be prepared to make changes requested by reviewers.</li> </ol>"},{"location":"contributing/CONTRIBUTING.html#style-guide","title":"Style Guide","text":"<ul> <li>Follow the PEP 8 style guide for Python code.</li> <li>Use type hints where appropriate.</li> <li>Ensure that your code is well-documented.</li> <li>Use meaningful variable and function names.</li> </ul> <p>Thank you for your contributions!</p>"},{"location":"contributing/DevelopingValidation.html","title":"Contributing a new Validation to Validoopsie","text":"<p>Creating a new validation might seem complex at first, but don\u2019t worry\u2014we\u2019ve made the process as straightforward as possible. Validations are dynamically imported from the <code>validoopsie/validation_catalogue</code> directory, and once you create your first one, everything will start to make sense!</p> <p>Follow these steps to create a new validation:</p>"},{"location":"contributing/DevelopingValidation.html#1-organize-your-validation","title":"1. Organize Your Validation","text":"<p>In the <code>validoopsie/validation_catalogue</code> directory, validations are organized by category. For this example, we\u2019ll create a validation to check whether values in a column fall between two numbers.</p> <p>Since this is a value-based validation, you\u2019ll create the file inside the <code>ValuesValidation</code> folder.</p>"},{"location":"contributing/DevelopingValidation.html#2-create-the-validation-file","title":"2. Create the Validation File","text":"<ol> <li>Create a new file in <code>validoopsie/validation_catalogue/ValuesValidation</code>.</li> <li>Name the file using this convention:    File Name: <code>column_values_to_be_between.py</code> Class Name: <code>ColumnValuesToBeBetween</code></li> </ol>"},{"location":"contributing/DevelopingValidation.html#3-define-the-validation-class","title":"3. Define the Validation Class","text":"<p>Your class should inherit from <code>BaseValidation</code>.</p> <p>Here\u2019s an example:</p> <pre><code>from validoopsie.base import BaseValidation\n# We will use these later\nfrom typing import Literal\nfrom narwhals.typing import Frame\n\nclass ColumnValuesToBeBetween(BaseValidation):\n</code></pre>"},{"location":"contributing/DevelopingValidation.html#4-add-a-docstring","title":"4. Add a Docstring","text":"<p>Include a clear docstring and doctest for both the class and its methods, these will also be  reused for the stub file later on. Here\u2019s an example structure:</p> <pre><code>\"\"\"Check if the values in a column are within a specific range.\n\nArgs:\n    column (str): Column to validate.\n    min_value (int): Minimum value.\n    max_value (int): Maximum value.\n    threshold (float, optional): Validation threshold. Defaults to 0.0.\n    impact (str, optional): Impact level of validation. Defaults to \"low\".\n    kwargs (dict): Additional keyword arguments.\n\nExamples:\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; from validoopsie import Validate\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Validate numeric range\n    &gt;&gt;&gt; df = pd.DataFrame({\n    ...     \"age\": [25, 30, 42, 18, 65]\n    ... })\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; vd = (\n    ...     Validate(df)\n    ...     .ValuesValidation.ColumnValuesToBeBetween(\n    ...         column=\"age\",\n    ...         min_value=18,\n    ...         max_value=65\n    ...     )\n    ... )\n    &gt;&gt;&gt; key = \"ColumnValuesToBeBetween_age\"\n    &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n    'Success'\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n    &gt;&gt;&gt; vd.validate()\n\n\"\"\"\n</code></pre> <p>Doctest servers as a double purpose, it provides examples on how to use the validation,  automatically showcased in the documentation and also serves as a test case for the  validation.</p>"},{"location":"contributing/DevelopingValidation.html#5-implement-the-__init__-method","title":"5. Implement the <code>__init__</code> Method","text":"<p>The <code>__init__</code> method must include <code>column</code> (if your validation uses a combination of columns or some other varation pass it later to <code>super().__init__</code>).</p> <p>In this case we are attempting to find values between two numbers, hence, these parameters are required: <code>column</code>, <code>min_value</code>, and <code>max_value</code>. It should also include the standard <code>impact</code> and <code>threshold</code> parameters required by the base class (<code>BaseValidation</code>).</p> <ul> <li>Always pass <code>column</code>, <code>impact</code>, and <code>threshold</code> to the base class.</li> <li>If your validation doesn\u2019t require a column, generate one in the <code>__init__</code> method.</li> </ul> <p>Example:</p> <pre><code>def __init__(\n    self,\n    column: str,\n    min_value: float,\n    max_value: float,\n    impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n    threshold: float = 0.00,\n    **kwargs: dict[str, object],\n) -&gt; None:\n    super().__init__(column, impact, threshold, **kwargs)\n    self.min_value = min_value\n    self.max_value = max_value\n</code></pre>"},{"location":"contributing/DevelopingValidation.html#6-add-a-fail-message","title":"6. Add a Fail Message","text":"<p>The fail message is included in the output report if the validation fails. Define it using a property:</p> <pre><code>@property\ndef fail_message(self) -&gt; str:\n    \"\"\"Return the fail message used in the report.\"\"\"\n    return (\n        f\"The column '{self.column}' has values that are not \"\n        f\"between {self.min_value} and {self.max_value}.\"\n    )\n</code></pre>"},{"location":"contributing/DevelopingValidation.html#7-define-the-validation-logic-__call__-method","title":"7. Define the Validation Logic (<code>__call__</code> Method)","text":"<p>The <code>__call__</code> method contains the core logic of your validation. It should return only the failed values.</p> <p>Example:</p> <pre><code>def __call__(self, frame: Frame) -&gt; Frame:\n    \"\"\"Check if the values in a column are within the specified range.\n\n    The result will be used during execution.\n    \"\"\"\n    return (\n        frame.group_by(self.column)\n        .agg(nw.col(self.column).count().alias(f\"{self.column}-count\"))\n        .filter(\n            nw.col(self.column).is_between(self.min_value, self.max_value) == False,\n        )\n    )\n</code></pre>"},{"location":"contributing/DevelopingValidation.html#8-test-your-validation","title":"8. Test Your Validation","text":"<p>Prior to proceeding with test generation, you might want to use your already generated test in the docstring, for that you can run: <pre><code>    uv run pytest validoopsie --doctest-modules\n</code></pre></p> <ol> <li>Create a test file under <code>tests/test_validation_catalogue/test_ValuesValidation</code>.</li> <li>Use the <code>@create_frame_fixture</code> decorator to define test data for different    DataFrame libraries (<code>pandas</code>, <code>polars</code>, <code>pyarrow</code>, etc.).</li> </ol> <p>Example:</p> <pre><code>from tests.utils.create_frames import create_frame_fixture\n\n@create_frame_fixture\ndef lf() -&gt; dict[str, list]:\n    return {\n        \"A\": [1, 2, 3, 4, 5],\n        \"B\": [1.0, 2.0, 3.0, 4.0, 5.0],\n    }\n</code></pre> <ol> <li>Write test cases for your validation:</li> </ol> <pre><code>def test_column_values_to_be_between(lf: Frame) -&gt; None:\n    test = ColumnValuesToBeBetween(\"A\", 1, 2)\n    result = test.__execute_check__(frame=lf)\n    assert result[\"result\"][\"status\"] == \"Fail\"\n</code></pre>"},{"location":"contributing/DevelopingValidation.html#9-update-the-stub-file-for-type-hinting","title":"9. Update the Stub File for Type Hinting","text":"<p>To enable proper type hinting for your new validation, update the stub file (<code>validate.pyi</code>). This step is essential because validations are dynamically imported.</p> <p>Add your validation like this:</p> <pre><code>class Validate:\n    class ValuesValidation:\n        @staticmethod\n        def ColumnValuesToBeBetween(\n            column: str,\n            min_value: int,\n            max_value: int,\n            threshold: float = 0.00,\n            impact: str = \"low\",\n            **kwargs: KwargsType,\n        ) -&gt; Validate:\n            \"\"\"Check if the values in a column are within a specific range.\n\n            Args:\n                column (str): Column to validate.\n                min_value (int): Minimum value.\n                max_value (int): Maximum value.\n                threshold (float, optional): Validation threshold. Defaults to 0.0.\n                impact (str, optional): Impact level of validation. Defaults to \"low\".\n                kwargs (dict): Additional keyword arguments.\n\n            Examples:\n                &gt;&gt;&gt; import pandas as pd\n                &gt;&gt;&gt; from validoopsie import Validate\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # Validate numeric range\n                &gt;&gt;&gt; df = pd.DataFrame({\n                ...     \"age\": [25, 30, 42, 18, 65]\n                ... })\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; vd = (\n                ...     Validate(df)\n                ...     .ValuesValidation.ColumnValuesToBeBetween(\n                ...         column=\"age\",\n                ...         min_value=18,\n                ...         max_value=65\n                ...     )\n                ... )\n                &gt;&gt;&gt; key = \"ColumnValuesToBeBetween_age\"\n                &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n                'Success'\n                &gt;&gt;&gt;\n                &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n                &gt;&gt;&gt; vd.validate()\n\n            \"\"\"\n</code></pre> <p>Make sure to include a docstring here as well since they\u2019re dynamically imported.</p>"},{"location":"contributing/DevelopingValidation.html#all-done","title":"All Done!","text":"<p>Congratulations! You\u2019ve just created your first validation. \ud83c\udf89</p> <p>If you have any questions or run into issues, feel free to reach out for help. Thank you for contributing!</p>"},{"location":"custom_validations/DevelopingValidationCustom.html","title":"Developing a Custom Validation","text":"<p>In certain situations, the default validations may not be sufficient to check the quality of your data, especially when dealing with complex cases. To handle these scenarios, you can develop your own custom validation that encapsulates the specific logic required for your data quality checks.</p> <p>This guide will walk you through the process of developing a custom validation using the Validoopsie library.</p>"},{"location":"custom_validations/DevelopingValidationCustom.html#final-output","title":"Final Output","text":"<pre><code>from typing import Literal\nfrom validoopsie.base import BaseValidation\nfrom narwhals.typing import FrameT\n\nclass MyCustomValidation(BaseValidation):\n    \"\"\"Custom validation that filters temperature data based on grouped dates.\n\n    Args:\n        column (str): The column name used in the validation and as an identifier in results.\n        threshold (float, optional): The threshold for the validation. Defaults to 0.0.\n        impact (str, optional): The impact level of the validation. Defaults to \"low\".\n        kwargs (dict): Additional keyword arguments.\n\n    \"\"\"\n    def __init__(\n        self,\n        column: str,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n    ) -&gt; None:\n        super().__init__(column, impact, threshold, **kwargs)\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message used in the report.\"\"\"\n        return \"Custom validation failed: Temperature readings are outside acceptable ranges.\"\n\n    def __call__(self, frame: FrameT) -&gt; FrameT:\n        \"\"\"Execute the custom validation logic.\n\n        Args:\n            frame (FrameT): The data frame to validate.\n\n        Returns:\n            FrameT: A data frame containing records that failed the validation.\n        \"\"\"\n        return (\n            frame.group_by(self.column)\n            .agg(nw.col(\"temperature\").mean().alias(\"mean_temperature_farenheit\"))\n            .with_columns(\n                ((nw.col(\"mean_temperature_farenheit\") - 32) * 5 / 9).alias(\n                    \"mean_temperature_celsius\",\n                ),\n            )\n            .filter(\n                # Every tempearture above 60 degrees celsius is considered as an error\n                nw.col(\"mean_temperature_celsius\") &gt; 60,\n                # Every tempearture below -40 degrees celsius is considered as an error\n                nw.col(\"mean_temperature_celsius\") &lt; -40,\n                # Every mean tempearture below -10 and above 30 degrees celsius is considered as an error\n                nw.col(\"mean_temperature_celsius\").is_between(-10, 30) == False,\n            )\n            .group_by(self.column)\n            .agg(nw.col(self.column).count().alias(f\"{self.column}-count\"))\n        )\n</code></pre>"},{"location":"custom_validations/DevelopingValidationCustom.html#1-define-the-validation-class","title":"1. Define the Validation Class","text":"<p>To create a custom validation, start by defining a new class that inherits from <code>BaseValidation</code>:</p> <pre><code>from typing import Literal\nfrom validoopsie.base import BaseValidation\nfrom narwhals.typing import FrameT\n\nclass MyCustomValidation(BaseValidation):\n</code></pre>"},{"location":"custom_validations/DevelopingValidationCustom.html#2-add-a-docstring","title":"2. Add a Docstring","text":"<p>While not strictly required, adding a docstring is best practice, especially for team collaboration and future maintenance. The docstring should describe the purpose of the validation and explain the parameters.</p> <p>Example:</p> <pre><code>\"\"\"Custom validation that filters temperature data based on grouped dates.\n\nArgs:\n    column (str): The column name used in the validation and as an identifier in results.\n    threshold (float, optional): The threshold for the validation. Defaults to 0.0.\n    impact (str, optional): The impact level of the validation. Defaults to \"low\".\n    kwargs (dict): Additional keyword arguments.\n\n\"\"\"\n</code></pre>"},{"location":"custom_validations/DevelopingValidationCustom.html#3-define-the-__init__-method","title":"3. Define the <code>__init__</code> Method","text":"<p>The <code>__init__</code> method initializes your validation class. It should include at least the <code>column</code> parameter, along with impact and threshold parameters. The base class requires these parameters to be passed explicitly.</p> <p>Example:</p> <pre><code>    def __init__(\n        self,\n        column: str,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n    ) -&gt; None:\n        super().__init__(column, impact, threshold, **kwargs)\n</code></pre>"},{"location":"custom_validations/DevelopingValidationCustom.html#4-add-a-fail-message","title":"4. Add a Fail Message","text":"<p>The fail message is used in the output report if the validation fails. Define it using a property method to provide a meaningful message that aids in diagnosing issues.</p> <p>Example:</p> <pre><code>    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message used in the report.\"\"\"\n        return \"Custom validation failed: Temperature readings are outside acceptable ranges.\"\n</code></pre>"},{"location":"custom_validations/DevelopingValidationCustom.html#5-define-the-validation-logic-__call__-method","title":"5. Define the Validation Logic (<code>__call__</code> Method)","text":"<p>The <code>__call__</code> method contains the core logic of your validation. This method should return only the records that do not meet the validation criteria.</p> <p>Example:</p> <pre><code>    def __call__(self, frame: FrameT) -&gt; FrameT:\n        \"\"\"Execute the custom validation logic.\n\n        Args:\n            frame (FrameT): The data frame to validate.\n\n        Returns:\n            FrameT: A data frame containing records that failed the validation.\n        \"\"\"\n        return (\n            frame.group_by(self.column)\n            .agg(nw.col(\"temperature\").mean().alias(\"mean_temperature_farenheit\"))\n            .with_columns(\n                ((nw.col(\"mean_temperature_farenheit\") - 32) * 5 / 9).alias(\n                    \"mean_temperature_celsius\",\n                ),\n            )\n            .filter(\n                # Every tempearture above 60 degrees celsius is considered as an error\n                nw.col(\"mean_temperature_celsius\") &gt; 60,\n                # Every tempearture below -40 degrees celsius is considered as an error\n                nw.col(\"mean_temperature_celsius\") &lt; -40,\n                # Every mean tempearture below -10 and above 30 degrees celsius is considered as an error\n                nw.col(\"mean_temperature_celsius\").is_between(-10, 30) == False,\n            )\n            .group_by(self.column)\n            .agg(nw.col(self.column).count().alias(f\"{self.column}-count\"))\n        )\n</code></pre> <p>Notes:</p> <ul> <li>Ensure that the logic correctly identifies and returns only the failing records.</li> </ul>"},{"location":"custom_validations/DevelopingValidationCustom.html#6-add-the-validation-to-the-pipeline","title":"6. Add the Validation to the Pipeline","text":"<p>To integrate your custom validation into the data validation pipeline, use the <code>add_validation</code> method of the <code>Validate</code> class.</p> <p>Example:</p> <pre><code>import pandas as pd\nfrom validoopsie import Validate\n\n# Sample data frame\ndf = pd.DataFrameT({\n    \"date\": ['2025-01-01', '2025-02-01', '2025-03-01', '2025-04-01'],\n    \"temperature\": [50, 60, 70, 80],\n})\n\n# Initialize the Validate object\nvalidator = Validate(df)\n\n# Add your custom validation\nvalidator.add_validation(MyCustomValidation(column=\"date\"))\n\n# Access the results directly\nresult = validator.results\n\nprint(result)\n</code></pre>"},{"location":"custom_validations/DevelopingValidationCustom.html#7-example-output","title":"7. Example Output","text":"<p>After running the validation, you can expect an output similar to the following:</p> <pre><code>{\n    \"Summary\": {\n        \"passed\": true,\n        \"validations\": [\n            \"MyCustomValidation_date\"\n        ]\n    },\n    \"MyCustomValidation_date\": {\n        \"validation\": \"MyCustomValidation\",\n        \"impact\": \"low\",\n        \"timestamp\": \"2025-01-10T17:54:14.035378+01:00\",\n        \"column\": \"date\",\n        \"result\": {\n            \"status\": \"Success\",\n            \"threshold pass\": true,\n            \"message\": \"All items passed the validation.\",\n            \"frame row number\": 4,\n            \"threshold\": 0.0\n        }\n    }\n}\n</code></pre> <p>With this guide, you should be able to create custom validations tailored to your specific data quality requirements. Remember to thoroughly test your custom validation to ensure it behaves as expected in all scenarios.</p>"},{"location":"custom_validations/naming_conventions.html","title":"Naming Conventions for Custom Validations","text":"<p>When creating custom validations for Validoopsie, following a consistent naming convention helps maintain code readability and ensures your validations integrate seamlessly with the library. This guide outlines the recommended naming patterns.</p>"},{"location":"custom_validations/naming_conventions.html#class-naming-convention","title":"Class Naming Convention","text":"<p>Custom validation classes should follow PascalCase (also known as UpperCamelCase) naming:</p> <pre><code>class ColumnValuesToBeBetween(BaseValidationParameters):\n    # Implementation\n</code></pre> <p>The class name should be descriptive and indicate:</p> <ol> <li> <p>What is being validated (e.g., \"Column\", \"DataType\", \"String\")</p> </li> <li> <p>The type of validation (e.g., \"ToBeBetween\", \"NotBeNull\", \"Match\")</p> </li> </ol>"},{"location":"custom_validations/naming_conventions.html#file-naming-convention","title":"File Naming Convention","text":"<p>Files containing validation classes should follow snake_case naming and match the class name:</p> <ul> <li>Class: <code>ColumnValuesToBeBetween</code></li> <li>File: <code>column_values_to_be_between.py</code></li> </ul>"},{"location":"custom_validations/naming_conventions.html#naming-patterns-by-validation-type","title":"Naming Patterns by Validation Type","text":"<p>Follow these patterns for different types of validations:</p>"},{"location":"custom_validations/naming_conventions.html#value-validations","title":"Value Validations","text":"<ul> <li><code>ColumnValuesToBeEqual</code> - Check if values equal a specific value</li> <li><code>ColumnValuesToBeBetween</code> - Check if values fall within a range</li> <li><code>ColumnValuesToBeGreaterThan</code> - Check if values exceed a threshold</li> </ul>"},{"location":"custom_validations/naming_conventions.html#string-validations","title":"String Validations","text":"<ul> <li><code>PatternMatch</code> - Check if strings match a regex pattern</li> <li><code>NotPatternMatch</code> - Check if strings don't match a regex pattern</li> <li><code>LengthToBeEqual</code> - Check if string length equals a specific value</li> <li><code>LengthToBeBetween</code> - Check if string length falls within a range</li> </ul>"},{"location":"custom_validations/naming_conventions.html#null-validations","title":"Null Validations","text":"<ul> <li><code>ColumnBeNull</code> - Check if values are null</li> <li><code>ColumnNotBeNull</code> - Check if values are not null</li> </ul>"},{"location":"custom_validations/naming_conventions.html#type-validations","title":"Type Validations","text":"<ul> <li><code>TypeCheck</code> - Check if values are of a specific type</li> </ul>"},{"location":"custom_validations/naming_conventions.html#date-validations","title":"Date Validations","text":"<ul> <li><code>DateToBeBetween</code> - Check if dates fall within a range</li> <li><code>ColumnMatchDateFormat</code> - Check if date strings match a format</li> </ul>"},{"location":"custom_validations/naming_conventions.html#organizing-custom-validations","title":"Organizing Custom Validations","text":"<p>Organize your custom validations in a logical category structure:</p> <pre><code>my_project/\n\u251c\u2500\u2500 validations/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 date_validations/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 fiscal_quarter_match.py\n\u2502   \u251c\u2500\u2500 string_validations/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 country_code_match.py\n\u2502   \u2514\u2500\u2500 custom_validations/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 business_rule_check.py\n</code></pre>"},{"location":"custom_validations/naming_conventions.html#registering-custom-validations","title":"Registering Custom Validations","text":"<p>When registering custom validations with Validoopsie, use a descriptive name that follows the same convention:</p> <pre><code>from validoopsie import Validate\nfrom my_project.validations.custom_validations.business_rule_check import BusinessRuleCheck\n\n# Create validator instance\nvalidator = Validate(df)\n\n# Add custom validation\nvalidator.add_validation(BusinessRuleCheck(column=\"transaction_type\", impact=\"high\"))\n</code></pre>"},{"location":"custom_validations/naming_conventions.html#examples-of-well-named-custom-validations","title":"Examples of Well-Named Custom Validations","text":""},{"location":"custom_validations/naming_conventions.html#good-examples","title":"Good Examples:","text":"<ul> <li><code>TransactionIdsUnique</code> - Checks if transaction IDs are unique</li> <li><code>CustomerCodeMatchPattern</code> - Validates customer code format</li> <li><code>DateWithinFiscalYear</code> - Ensures dates fall within fiscal year</li> <li><code>AmountSumEqualsTotal</code> - Verifies that amounts sum to expected total</li> </ul>"},{"location":"custom_validations/naming_conventions.html#poor-examples-avoid","title":"Poor Examples (Avoid):","text":"<ul> <li><code>Check1</code> - Too vague</li> <li><code>ValidateThis</code> - Doesn't describe what's being validated</li> <li><code>MyCustomVal</code> - Not descriptive</li> <li><code>DoStuff</code> - Doesn't explain the validation purpose</li> </ul>"},{"location":"custom_validations/naming_conventions.html#type-hinting-for-custom-validations","title":"Type Hinting for Custom Validations","text":"<p>When adding type hints, follow this pattern:</p> <pre><code>    def __init__(\n        self,\n        column: str,\n        pattern: str,\n        threshold: float = 0.0,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n    ) -&gt; None:\n        # Implementation\n</code></pre> <p>By following these naming conventions, you ensure that your custom validations are easily understood by other developers and integrate well with Validoopsie's existing validation structure.</p>"},{"location":"validation_catalogue/Date%20Validation.html","title":"Date Validation","text":""},{"location":"validation_catalogue/Date%20Validation.html#validation_catalogue.DateValidation.ColumnMatchDateFormat","title":"ColumnMatchDateFormat","text":"<p>Check if the values in a column match the date format.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Column to validate.</p> required <code>date_format</code> <code>str</code> <p>Date format to check.</p> required <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate dates match format\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"dates_iso\": [\"2023-01-01\", \"2023-02-15\", \"2023-03-30\"],\n...     \"dates_mixed\": [\"2023-01-01\", \"02/15/2023\", \"2023-03-30\"]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .DateValidation.ColumnMatchDateFormat(\n...         column=\"dates_iso\",\n...         date_format=\"YYYY-mm-dd\"\n...     )\n... )\n&gt;&gt;&gt; key = \"ColumnMatchDateFormat_dates_iso\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n</code></pre> <pre><code>&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With threshold allowing some failures\n&gt;&gt;&gt; vd2 = (\n...     Validate(df)\n...     .DateValidation.ColumnMatchDateFormat(\n...         column=\"dates_mixed\",\n...         date_format=\"YYYY-mm-dd\",\n...         threshold=0.4  # Allow 40% failure rate\n...     )\n... )\n&gt;&gt;&gt; key2 = \"ColumnMatchDateFormat_dates_mixed\"\n&gt;&gt;&gt; vd2.results[key2][\"result\"][\"status\"]\n'Success'\n</code></pre> Source code in <code>validoopsie/validation_catalogue/DateValidation/column_match_date_format.py</code> <pre><code>class ColumnMatchDateFormat(BaseValidation):\n    \"\"\"Check if the values in a column match the date format.\n\n    Args:\n        column (str): Column to validate.\n        date_format (str): Date format to check.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of validation.\n            Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate dates match format\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"dates_iso\": [\"2023-01-01\", \"2023-02-15\", \"2023-03-30\"],\n        ...     \"dates_mixed\": [\"2023-01-01\", \"02/15/2023\", \"2023-03-30\"]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .DateValidation.ColumnMatchDateFormat(\n        ...         column=\"dates_iso\",\n        ...         date_format=\"YYYY-mm-dd\"\n        ...     )\n        ... )\n        &gt;&gt;&gt; key = \"ColumnMatchDateFormat_dates_iso\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # With threshold allowing some failures\n        &gt;&gt;&gt; vd2 = (\n        ...     Validate(df)\n        ...     .DateValidation.ColumnMatchDateFormat(\n        ...         column=\"dates_mixed\",\n        ...         date_format=\"YYYY-mm-dd\",\n        ...         threshold=0.4  # Allow 40% failure rate\n        ...     )\n        ... )\n        &gt;&gt;&gt; key2 = \"ColumnMatchDateFormat_dates_mixed\"\n        &gt;&gt;&gt; vd2.results[key2][\"result\"][\"status\"]\n        'Success'\n\n    \"\"\"\n\n    def __init__(\n        self,\n        column: str,\n        date_format: str,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        self.date_format = date_format\n        super().__init__(column, impact, threshold, **kwargs)\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        return f\"The column '{self.column}' has unique values that are not in the list.\"\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Check if the values in a column match the date format.\"\"\"\n        date_patterns = re.findall(r\"[Ymd]+\", self.date_format)\n        separators = re.findall(r\"[^Ymd]+\", self.date_format)\n\n        pattern_parts = []\n        for i, date_p in enumerate(date_patterns):\n            pattern_parts.append(rf\"\\d{{{len(date_p)}}}\")\n            if i &lt; len(separators):\n                pattern_parts.append(re.escape(separators[i]))\n\n        pattern = \"^\" + \"\".join(pattern_parts) + \"$\"\n        exp = nw.col(self.column).cast(nw.String).str.contains(pattern).alias(\"contains\")\n        return (\n            frame.with_columns(exp)\n            .filter(nw.col(\"contains\") == False)\n            .select(nw.col(self.column).cast(nw.String))\n            .group_by(self.column)\n            .agg(nw.col(self.column).count().alias(f\"{self.column}-count\"))\n        )\n</code></pre>"},{"location":"validation_catalogue/Date%20Validation.html#validation_catalogue.DateValidation.DateToBeBetween","title":"DateToBeBetween","text":"<p>Check if the column date is between min-max range.</p> <p>If the <code>min_date</code> or <code>max_date</code> is not provided then other will be used as the threshold.</p> <p>If neither <code>min_date</code> nor <code>max_date</code> is provided, then the validation will result in failure.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Column to validate.</p> required <code>min_date</code> <code>date | datetime | None</code> <p>Minimum date for a column entry length.</p> <code>None</code> <code>max_date</code> <code>date | datetime | None</code> <p>Maximum date for a column entry length.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate dates are within range\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"order_date\": [\n...         datetime(2023, 1, 15),\n...         datetime(2023, 2, 20),\n...         datetime(2023, 3, 25)\n...     ]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .DateValidation.DateToBeBetween(\n...         column=\"order_date\",\n...         min_date=datetime(2023, 1, 1),\n...         max_date=datetime(2023, 12, 31)\n...     )\n... )\n&gt;&gt;&gt; key = \"DateToBeBetween_order_date\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/DateValidation/date_to_be_between.py</code> <pre><code>class DateToBeBetween(BaseValidation):\n    \"\"\"Check if the column date is between min-max range.\n\n    If the `min_date` or `max_date` is not provided then other will be used as the\n    threshold.\n\n    If neither `min_date` nor `max_date` is provided, then the validation will result\n    in failure.\n\n    Args:\n        column (str): Column to validate.\n        min_date (date | datetime | None): Minimum date for a column entry length.\n        max_date (date | datetime | None): Maximum date for a column entry length.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of validation.\n            Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; import narwhals as nw\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate dates are within range\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"order_date\": [\n        ...         datetime(2023, 1, 15),\n        ...         datetime(2023, 2, 20),\n        ...         datetime(2023, 3, 25)\n        ...     ]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .DateValidation.DateToBeBetween(\n        ...         column=\"order_date\",\n        ...         min_date=datetime(2023, 1, 1),\n        ...         max_date=datetime(2023, 12, 31)\n        ...     )\n        ... )\n        &gt;&gt;&gt; key = \"DateToBeBetween_order_date\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        column: str,\n        min_date: date | datetime | None = None,\n        max_date: date | datetime | None = None,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        min_max_arg_check(min_date, max_date)\n\n        super().__init__(column, impact, threshold, **kwargs)\n        self.min_date = min_date\n        self.max_date = max_date\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        return (\n            f\"The column '{self.column}' has date range outside \"\n            f\"[{self.min_date}, {self.max_date}].\"\n        )\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Check if the string lengths are between the specified range.\"\"\"\n        return (\n            min_max_filter(\n                frame,\n                f\"{self.column}\",\n                self.min_date,\n                self.max_date,\n            )\n            .group_by(self.column)\n            .agg(nw.col(self.column).count().alias(f\"{self.column}-count\"))\n            .with_columns(nw.col(self.column).cast(nw.String).alias(self.column))\n        )\n</code></pre>"},{"location":"validation_catalogue/Equality%20Validation.html","title":"Equality Validation","text":""},{"location":"validation_catalogue/Equality%20Validation.html#validation_catalogue.EqualityValidation.PairColumnEquality","title":"PairColumnEquality","text":"<p>Check if the pair of columns are equal.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Column to validate.</p> required <code>target_column</code> <code>str</code> <p>Column to compare.</p> required <code>group_by_combined</code> <code>bool</code> <p>Group by combine columns. Default True.</p> <code>True</code> <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate columns match\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"amount\": [100, 200, 300],\n...     \"verified_amount\": [100, 200, 300]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .EqualityValidation.PairColumnEquality(\n...         column=\"amount\",\n...         target_column=\"verified_amount\"\n...     )\n... )\n&gt;&gt;&gt; key = \"PairColumnEquality_amount\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/EqualityValidation/pair_column_equality.py</code> <pre><code>class PairColumnEquality(BaseValidation):\n    \"\"\"Check if the pair of columns are equal.\n\n    Args:\n        column (str): Column to validate.\n        target_column (str): Column to compare.\n        group_by_combined (bool, optional): Group by combine columns. Default True.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of validation.\n            Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate columns match\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"amount\": [100, 200, 300],\n        ...     \"verified_amount\": [100, 200, 300]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .EqualityValidation.PairColumnEquality(\n        ...         column=\"amount\",\n        ...         target_column=\"verified_amount\"\n        ...     )\n        ... )\n        &gt;&gt;&gt; key = \"PairColumnEquality_amount\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        column: str,\n        target_column: str,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        *,\n        group_by_combined: bool = True,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        super().__init__(column, impact, threshold, **kwargs)\n        self.target_column = target_column\n        self.group_by_combined = group_by_combined\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        return (\n            f\"The column '{self.column}' is not equal to the column\"\n            f\"'{self.target_column}'.\"\n        )\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Check if the pair of columns are equal.\"\"\"\n        select_columns = [self.column, f\"{self.column}-count\"]\n        gb_cols = (\n            [self.column, self.target_column] if self.group_by_combined else [self.column]\n        )\n\n        validated_frame = (\n            frame.filter(\n                nw.col(self.column) != nw.col(self.target_column),\n            )\n            .group_by(gb_cols)\n            .agg(nw.col(self.column).count().alias(f\"{self.column}-count\"))\n        )\n\n        if self.group_by_combined:\n            validated_frame = validated_frame.with_columns(\n                nw.concat_str(\n                    [\n                        nw.col(self.column),\n                        nw.col(self.target_column),\n                    ],\n                    separator=f\" - column {self.column} - column {self.target_column} - \",\n                ).alias(self.column),\n            )\n\n        return validated_frame.select(select_columns)\n</code></pre>"},{"location":"validation_catalogue/Null%20Validation.html","title":"Null Validation","text":""},{"location":"validation_catalogue/Null%20Validation.html#validation_catalogue.NullValidation.ColumnBeNull","title":"ColumnBeNull","text":"<p>Check if the values in a column are null.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Column to validate.</p> required <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate field contains only nulls\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"id\": [1, 2, 3],\n...     \"optional_field\": [None, None, None]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .NullValidation.ColumnBeNull(column=\"optional_field\")\n... )\n&gt;&gt;&gt; key = \"ColumnBeNull_optional_field\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/NullValidation/column_be_null.py</code> <pre><code>class ColumnBeNull(BaseValidation):\n    \"\"\"Check if the values in a column are null.\n\n    Args:\n        column (str): Column to validate.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of validation.\n            Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate field contains only nulls\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"id\": [1, 2, 3],\n        ...     \"optional_field\": [None, None, None]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .NullValidation.ColumnBeNull(column=\"optional_field\")\n        ... )\n        &gt;&gt;&gt; key = \"ColumnBeNull_optional_field\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        column: str,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        super().__init__(column, impact, threshold, **kwargs)\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        return f\"The column '{self.column}' doesn't have values that are null.\"\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Check if the values in a column are null.\"\"\"\n        return (\n            frame.select(self.column)\n            .filter(\n                nw.col(self.column).is_null() == False,\n            )\n            .group_by(self.column)\n            .agg(nw.col(self.column).count().alias(f\"{self.column}-count\"))\n        )\n</code></pre>"},{"location":"validation_catalogue/Null%20Validation.html#validation_catalogue.NullValidation.ColumnNotBeNull","title":"ColumnNotBeNull","text":"<p>Check if the values in a column are not null.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Column to validate.</p> required <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate field has no nulls\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"id\": [1, 2, 3],\n...     \"required_field\": [\"a\", \"b\", \"c\"]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .NullValidation.ColumnNotBeNull(column=\"required_field\")\n... )\n&gt;&gt;&gt; key = \"ColumnNotBeNull_required_field\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/NullValidation/column_not_be_null.py</code> <pre><code>class ColumnNotBeNull(BaseValidation):\n    \"\"\"Check if the values in a column are not null.\n\n    Args:\n        column (str): Column to validate.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of validation.\n            Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate field has no nulls\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"id\": [1, 2, 3],\n        ...     \"required_field\": [\"a\", \"b\", \"c\"]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .NullValidation.ColumnNotBeNull(column=\"required_field\")\n        ... )\n        &gt;&gt;&gt; key = \"ColumnNotBeNull_required_field\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        column: str,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        super().__init__(column, impact, threshold, **kwargs)\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        return f\"The column '{self.column}' has values that are null.\"\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Check if the values in a column are not null.\"\"\"\n        null_count_col = f\"{self.column}-count\"\n        return (\n            frame.filter(\n                nw.col(self.column).is_null() == True,\n            )\n            .with_columns(nw.lit(1).alias(null_count_col))\n            .group_by(self.column)\n            .agg(nw.col(null_count_col).sum())\n        )\n</code></pre>"},{"location":"validation_catalogue/String%20Validation.html","title":"String Validation","text":""},{"location":"validation_catalogue/String%20Validation.html#validation_catalogue.StringValidation.LengthToBeBetween","title":"LengthToBeBetween","text":"<p>Check if the string lengths are between the specified range.</p> <p>If the <code>min_value</code> or <code>max_value</code> is not provided then other will be used as the threshold.</p> <p>If neither <code>min_value</code> nor <code>max_value</code> is provided, then the validation will result in failure.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Column to validate.</p> required <code>min_value</code> <code>float | None</code> <p>Minimum value for a column entry length.</p> <code>None</code> <code>max_value</code> <code>float | None</code> <p>Maximum value for a column entry length.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate string length\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"username\": [\"user1\", \"user2\", \"user3\"],\n...     \"password\": [\"pass123\", \"password\", \"p@ssw0rd\"]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .StringValidation.LengthToBeBetween(\n...         column=\"password\",\n...         min_value=6,\n...         max_value=10\n...     )\n... )\n&gt;&gt;&gt; key = \"LengthToBeBetween_password\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/StringValidation/length_to_be_between.py</code> <pre><code>class LengthToBeBetween(BaseValidation):\n    \"\"\"Check if the string lengths are between the specified range.\n\n    If the `min_value` or `max_value` is not provided then other will be used as the\n    threshold.\n\n    If neither `min_value` nor `max_value` is provided, then the validation will result\n    in failure.\n\n    Args:\n        column (str): Column to validate.\n        min_value (float | None): Minimum value for a column entry length.\n        max_value (float | None): Maximum value for a column entry length.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of validation.\n            Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate string length\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"username\": [\"user1\", \"user2\", \"user3\"],\n        ...     \"password\": [\"pass123\", \"password\", \"p@ssw0rd\"]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .StringValidation.LengthToBeBetween(\n        ...         column=\"password\",\n        ...         min_value=6,\n        ...         max_value=10\n        ...     )\n        ... )\n        &gt;&gt;&gt; key = \"LengthToBeBetween_password\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        column: str,\n        min_value: int | None = None,\n        max_value: int | None = None,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        min_max_arg_check(min_value, max_value)\n\n        super().__init__(column, impact, threshold, **kwargs)\n        self.min_value = min_value\n        self.max_value = max_value\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        return (\n            f\"The column '{self.column}' has string lengths outside the range\"\n            f\"[{self.min_value}, {self.max_value}].\"\n        )\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Check if the string lengths are between the specified range.\"\"\"\n        transformed_frame = frame.with_columns(\n            nw.col(self.column).str.len_chars().alias(f\"{self.column}-length\"),\n        )\n\n        return (\n            min_max_filter(\n                transformed_frame,\n                f\"{self.column}-length\",\n                self.min_value,\n                self.max_value,\n            )\n            .group_by(self.column)\n            .agg(nw.col(self.column).count().alias(f\"{self.column}-count\"))\n        )\n</code></pre>"},{"location":"validation_catalogue/String%20Validation.html#validation_catalogue.StringValidation.LengthToBeEqualTo","title":"LengthToBeEqualTo","text":"<p>Expect the column entries to be strings with length equal to <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Column to validate.</p> required <code>value</code> <code>int</code> <p>The expected value for a column entry length.</p> required <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate fixed-length codes\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"country_code\": [\"US\", \"UK\", \"FR\"]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .StringValidation.LengthToBeEqualTo(\n...         column=\"country_code\",\n...         value=2\n...     )\n... )\n&gt;&gt;&gt; key = \"LengthToBeEqualTo_country_code\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/StringValidation/length_to_be_equal_to.py</code> <pre><code>class LengthToBeEqualTo(BaseValidation):\n    \"\"\"Expect the column entries to be strings with length equal to `value`.\n\n    Args:\n        column (str): Column to validate.\n        value (int): The expected value for a column entry length.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of validation.\n            Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate fixed-length codes\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"country_code\": [\"US\", \"UK\", \"FR\"]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .StringValidation.LengthToBeEqualTo(\n        ...         column=\"country_code\",\n        ...         value=2\n        ...     )\n        ... )\n        &gt;&gt;&gt; key = \"LengthToBeEqualTo_country_code\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        column: str,\n        value: int,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        super().__init__(column, impact, threshold, **kwargs)\n        self.value = value\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        return (\n            f\"The column '{self.column}' has entries with length not \"\n            f\"equal to {self.value}.\"\n        )\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Expect the column entries to be strings with length equal to `value`.\"\"\"\n        return (\n            frame.filter(\n                nw.col(self.column).str.len_chars() != self.value,\n            )\n            .group_by(self.column)\n            .agg(nw.col(self.column).count().alias(f\"{self.column}-count\"))\n        )\n</code></pre>"},{"location":"validation_catalogue/String%20Validation.html#validation_catalogue.StringValidation.NotPatternMatch","title":"NotPatternMatch","text":"<p>Expect the column entries to be strings that do not pattern match.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>pattern</code> <code>str</code> <p>The pattern expression the column should not match.</p> required <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate text doesn't contain pattern\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"comment\": [\"Great product!\", \"Normal comment\", \"Just okay\"]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .StringValidation.NotPatternMatch(\n...         column=\"comment\",\n...         pattern=r\"password\"\n...     )\n... )\n&gt;&gt;&gt; key = \"NotPatternMatch_comment\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/StringValidation/not_pattern_match.py</code> <pre><code>class NotPatternMatch(BaseValidation):\n    \"\"\"Expect the column entries to be strings that do not pattern match.\n\n    Args:\n        column (str): The column name.\n        pattern (str): The pattern expression the column should not match.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of\n            validation. Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate text doesn't contain pattern\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"comment\": [\"Great product!\", \"Normal comment\", \"Just okay\"]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .StringValidation.NotPatternMatch(\n        ...         column=\"comment\",\n        ...         pattern=r\"password\"\n        ...     )\n        ... )\n        &gt;&gt;&gt; key = \"NotPatternMatch_comment\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        column: str,\n        pattern: str,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        super().__init__(column, impact, threshold, **kwargs)\n        self.pattern = pattern\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        return (\n            f\"The column '{self.column}' has entries that do not match \"\n            f\"the pattern '{self.pattern}'.\"\n        )\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Expect the column entries to be strings that do not pattern match.\"\"\"\n        return (\n            frame.filter(\n                nw.col(self.column).cast(nw.String).str.contains(self.pattern) == True,\n            )\n            .group_by(self.column)\n            .agg(nw.col(self.column).count().alias(f\"{self.column}-count\"))\n        )\n</code></pre>"},{"location":"validation_catalogue/String%20Validation.html#validation_catalogue.StringValidation.PatternMatch","title":"PatternMatch","text":"<p>Expect the column entries to be strings that pattern matches.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>pattern</code> <code>str</code> <p>The pattern expression the column should match.</p> required <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate email format\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"email\": [\"user1@example.com\", \"user2@example.com\"]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .StringValidation.PatternMatch(\n...         column=\"email\",\n...         pattern=r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n...     )\n... )\n&gt;&gt;&gt; key = \"PatternMatch_email\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/StringValidation/pattern_match.py</code> <pre><code>class PatternMatch(BaseValidation):\n    r\"\"\"Expect the column entries to be strings that pattern matches.\n\n    Args:\n        column (str): The column name.\n        pattern (str): The pattern expression the column should match.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of validation.\n            Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate email format\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"email\": [\"user1@example.com\", \"user2@example.com\"]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .StringValidation.PatternMatch(\n        ...         column=\"email\",\n        ...         pattern=r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n        ...     )\n        ... )\n        &gt;&gt;&gt; key = \"PatternMatch_email\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        column: str,\n        pattern: str,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        super().__init__(column, impact, threshold, **kwargs)\n        self.pattern = pattern\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        return (\n            f\"The column '{self.column}' has entries that do not match \"\n            f\"the pattern '{self.pattern}'.\"\n        )\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Expect the column entries to be strings that pattern matches.\"\"\"\n        return (\n            frame.filter(\n                nw.col(self.column).cast(nw.String).str.contains(self.pattern) == False,\n            )\n            .group_by(self.column)\n            .agg(nw.col(self.column).count().alias(f\"{self.column}-count\"))\n        )\n</code></pre>"},{"location":"validation_catalogue/Type%20Validation.html","title":"Type Validation","text":""},{"location":"validation_catalogue/Type%20Validation.html#validation_catalogue.TypeValidation.TypeCheck","title":"TypeCheck","text":"<p>Validate the data type of the column(s).</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str | None</code> <p>The column to validate.</p> <code>None</code> <code>column_type</code> <code>type | None</code> <p>The type of validation to perform.</p> <code>None</code> <code>frame_schema_definition</code> <code>dict[str, type] | None</code> <p>A dictionary of column names and their respective validation types.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt; from narwhals.dtypes import IntegerType, FloatType, String\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate column types\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"id\": [1001, 1002, 1003],\n...     \"name\": [\"Alice\", \"Bob\", \"Charlie\"],\n...     \"balance\": [100.50, 250.75, 0.00]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .TypeValidation.TypeCheck(\n...         frame_schema_definition={\n...             \"id\": IntegerType,\n...             \"name\": String,\n...             \"balance\": FloatType\n...         }\n...     )\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; key = \"TypeCheck_DataTypeColumnValidation\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/TypeValidation/type_check.py</code> <pre><code>class TypeCheck(BaseValidation):\n    \"\"\"Validate the data type of the column(s).\n\n    Args:\n        column (str | None): The column to validate.\n        column_type (type | None): The type of validation to perform.\n        frame_schema_definition (dict[str, type] | None): A dictionary\n            of column names and their respective validation types.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of validation.\n            Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt; from narwhals.dtypes import IntegerType, FloatType, String\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate column types\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"id\": [1001, 1002, 1003],\n        ...     \"name\": [\"Alice\", \"Bob\", \"Charlie\"],\n        ...     \"balance\": [100.50, 250.75, 0.00]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .TypeValidation.TypeCheck(\n        ...         frame_schema_definition={\n        ...             \"id\": IntegerType,\n        ...             \"name\": String,\n        ...             \"balance\": FloatType\n        ...         }\n        ...     )\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; key = \"TypeCheck_DataTypeColumnValidation\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        column: str | None = None,\n        column_type: type | None = None,\n        frame_schema_definition: dict[str, type] | None = None,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        # Single validation check\n        if column and column_type:\n            self.__check_validation_parameter__(column, column_type, DType)\n            self.column_type = column_type\n            self.frame_schema_definition = {column: column_type}\n\n        # Multiple validation checks\n        elif not column and not column_type and frame_schema_definition:\n            # Check if Validation inside of the dictionary is actually correct\n            for vcolumn, vtype in frame_schema_definition.items():\n                self.__check_validation_parameter__(vcolumn, vtype, DType)\n\n            column = \"DataTypeColumnValidation\"\n            self.frame_schema_definition = frame_schema_definition\n        else:\n            error_message = (\n                \"Either `column` and `validation_type` should be provided or \"\n                \"`frame_schema_definition` should be provided.\",\n            )\n            raise ValueError(error_message)\n\n        super().__init__(column, impact, threshold, **kwargs)\n\n    def __check_validation_parameter__(\n        self,\n        column: str,\n        column_type: type,\n        expected_type: type,\n    ) -&gt; None:\n        \"\"\"Check if the validation parameter is correct.\"\"\"\n        if not issubclass(column_type, expected_type):\n            error_message = (\n                f\"Validation type must be a subclass of DType, column: {column}, \"\n                f\"type: {column_type.__name__}.\"\n            )\n            raise TypeError(error_message)\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        if self.column == \"DataTypeColumnValidation\":\n            return (\n                \"The data type of the column(s) is not correct. \"\n                \"Please check `column_type_definitions`.\"\n            )\n\n        return (\n            f\"The column '{self.column}' has failed the Validation, \"\n            f\"expected type: {self.column_type}.\"\n        )\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Validate the data type of the column(s).\"\"\"\n        schema = frame.schema\n        # Introduction of a new structure where the schema len will be used a frame length\n        self.schema_length = schema.len()\n        failed_columns = []\n        for column_name in self.frame_schema_definition:\n            # Should this be raised or not?\n            if column_name not in schema:\n                failed_columns.append(column_name)\n                continue\n\n            column_type = schema[column_name]\n            defined_type = self.frame_schema_definition[column_name]\n\n            if not issubclass(column_type.__class__, defined_type):\n                failed_columns.append(column_name)\n\n        return nw.from_native(pa.table({self.column: failed_columns})).with_columns(\n            nw.lit(1).alias(f\"{self.column}-count\"),\n        )\n</code></pre>"},{"location":"validation_catalogue/Unique%20Validation.html","title":"Unique Validation","text":""},{"location":"validation_catalogue/Unique%20Validation.html#validation_catalogue.UniqueValidation.ColumnUniquePair","title":"ColumnUniquePair","text":"<p>Validates the uniqueness of combined values from multiple columns.</p> <p>This class checks if the combination of values from specified columns creates unique entries in the dataset. For example, if checking columns ['first_name', 'last_name'], the combination of these values should be unique for each row.</p> <p>Parameters:</p> Name Type Description Default <code>column_list</code> <code>list | tuple</code> <p>List or tuple of column names to check for unique combinations.</p> required <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate unique pairs\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"student_id\": [101, 102, 103],\n...     \"course_id\": [201, 202, 203],\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .UniqueValidation.ColumnUniquePair(\n...         column_list=[\"student_id\", \"course_id\"]\n...     )\n... )\n&gt;&gt;&gt; key = \"ColumnUniquePair_student_id - course_id\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/UniqueValidation/column_unique_pair.py</code> <pre><code>class ColumnUniquePair(BaseValidation):\n    \"\"\"Validates the uniqueness of combined values from multiple columns.\n\n    This class checks if the combination of values from specified columns creates unique\n    entries in the dataset. For example, if checking columns ['first_name', 'last_name'],\n    the combination of these values should be unique for each row.\n\n    Args:\n        column_list (list | tuple): List or tuple of column names to check for\n            unique combinations.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of\n            validation. Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate unique pairs\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"student_id\": [101, 102, 103],\n        ...     \"course_id\": [201, 202, 203],\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .UniqueValidation.ColumnUniquePair(\n        ...         column_list=[\"student_id\", \"course_id\"]\n        ...     )\n        ... )\n        &gt;&gt;&gt; key = \"ColumnUniquePair_student_id - course_id\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        column_list: list[str] | tuple[str, ...],\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        assert len(column_list) &gt; 0, \"At least two columns are required.\"\n\n        self.column_list = column_list\n        column = \" - \".join(column_list)\n        super().__init__(column, impact, threshold, **kwargs)\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return a descriptive message when the validation fails.\"\"\"\n        return (\n            f\"Duplicate entries found: The combination of columns [{self.column}] \"\n            \"contains non-unique values.\"\n        )\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Check if the unique values are in the list.\"\"\"\n        return (\n            frame.with_columns(\n                nw.concat_str(\n                    [nw.col(col) for col in self.column_list],\n                    separator=\" - \",\n                ).alias(self.column),\n            )\n            .group_by(self.column)\n            .agg(nw.len().alias(f\"{self.column}-count\"))\n            .filter(nw.col(f\"{self.column}-count\") &gt; 1)\n        )\n</code></pre>"},{"location":"validation_catalogue/Unique%20Validation.html#validation_catalogue.UniqueValidation.ColumnUniqueValueCountToBeBetween","title":"ColumnUniqueValueCountToBeBetween","text":"<p>Check the number of unique values in a column to be between min and max.</p> <p>If the <code>min_value</code> or <code>max_value</code> is not provided then other will be used as the threshold.</p> <p>If neither <code>min_value</code> nor <code>max_value</code> is provided, then the validation will result in failure.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column to validate.</p> required <code>min_value</code> <code>int or None</code> <p>The minimum number of unique values allowed.</p> <code>None</code> <code>max_value</code> <code>int or None</code> <p>The maximum number of unique values allowed.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate number of unique values\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"category\": [\"A\", \"B\", \"C\", \"A\", \"B\"]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .UniqueValidation.ColumnUniqueValueCountToBeBetween(\n...         column=\"category\",\n...         min_value=1,\n...         max_value=5\n...     )\n... )\n&gt;&gt;&gt; key = \"ColumnUniqueValueCountToBeBetween_category\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/UniqueValidation/column_unique_value_count_to_be_between.py</code> <pre><code>class ColumnUniqueValueCountToBeBetween(BaseValidation):\n    \"\"\"Check the number of unique values in a column to be between min and max.\n\n    If the `min_value` or `max_value` is not provided then other will be used as the\n    threshold.\n\n    If neither `min_value` nor `max_value` is provided, then the validation will result\n    in failure.\n\n    Args:\n        column (str): The column to validate.\n        min_value (int or None): The minimum number of unique values allowed.\n        max_value (int or None): The maximum number of unique values allowed.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of validation.\n            Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate number of unique values\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"category\": [\"A\", \"B\", \"C\", \"A\", \"B\"]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .UniqueValidation.ColumnUniqueValueCountToBeBetween(\n        ...         column=\"category\",\n        ...         min_value=1,\n        ...         max_value=5\n        ...     )\n        ... )\n        &gt;&gt;&gt; key = \"ColumnUniqueValueCountToBeBetween_category\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        column: str,\n        min_value: int | None = None,\n        max_value: int | None = None,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        min_max_arg_check(min_value, max_value)\n\n        super().__init__(column, impact, threshold, **kwargs)\n        self.min_value = min_value\n        self.max_value = max_value\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        return (\n            f\"The column '{self.column}' has a number of unique values that \"\n            f\"is not between {self.min_value} and {self.max_value}.\"\n        )\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Validate the number of unique values in the column.\"\"\"\n        unique_value_counts = frame.group_by(self.column).agg(\n            nw.col(self.column).count().alias(f\"{self.column}-count\"),\n        )\n\n        return min_max_filter(\n            unique_value_counts,\n            f\"{self.column}-count\",\n            self.min_value,\n            self.max_value,\n        )\n</code></pre>"},{"location":"validation_catalogue/Unique%20Validation.html#validation_catalogue.UniqueValidation.ColumnUniqueValuesToBeInList","title":"ColumnUniqueValuesToBeInList","text":"<p>Check if the unique values are in the list.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Column to validate.</p> required <code>values</code> <code>list[Union[str, float, int, None]]</code> <p>List of values to check.</p> required <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate values in allowed list\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"status\": [\"active\", \"inactive\", \"pending\"]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .UniqueValidation.ColumnUniqueValuesToBeInList(\n...         column=\"status\",\n...         values=[\"active\", \"inactive\", \"pending\"]\n...     )\n... )\n&gt;&gt;&gt; key = \"ColumnUniqueValuesToBeInList_status\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/UniqueValidation/column_unique_values_to_be_in_list.py</code> <pre><code>class ColumnUniqueValuesToBeInList(BaseValidation):\n    \"\"\"Check if the unique values are in the list.\n\n    Args:\n        column (str): Column to validate.\n        values (list[Union[str, float, int, None]]): List of values to check.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of\n            validation. Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate values in allowed list\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"status\": [\"active\", \"inactive\", \"pending\"]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .UniqueValidation.ColumnUniqueValuesToBeInList(\n        ...         column=\"status\",\n        ...         values=[\"active\", \"inactive\", \"pending\"]\n        ...     )\n        ... )\n        &gt;&gt;&gt; key = \"ColumnUniqueValuesToBeInList_status\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        column: str,\n        values: list[str | int | float | None],\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        super().__init__(column, impact, threshold, **kwargs)\n        self.values = values\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        return f\"The column '{self.column}' has unique values that are not in the list.\"\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Check if the unique values are in the list.\"\"\"\n        return (\n            frame.group_by(self.column)\n            .agg(nw.col(self.column).count().alias(f\"{self.column}-count\"))\n            .filter(\n                nw.col(self.column).is_in(self.values) == False,\n            )\n        )\n</code></pre>"},{"location":"validation_catalogue/Value%20Validation.html","title":"Value Validation","text":""},{"location":"validation_catalogue/Value%20Validation.html#validation_catalogue.ValuesValidation.ColumnValuesToBeBetween","title":"ColumnValuesToBeBetween","text":"<p>Check if the values in a column are between a range.</p> <p>If the <code>min_value</code> or <code>max_value</code> is not provided then other will be used as the threshold.</p> <p>If neither <code>min_value</code> nor <code>max_value</code> is provided, then the validation will result in failure.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Column to validate.</p> required <code>min_value</code> <code>float | None</code> <p>Minimum value for a column entry length.</p> <code>None</code> <code>max_value</code> <code>float | None</code> <p>Maximum value for a column entry length.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate numeric range\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"age\": [25, 30, 42, 18, 65]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .ValuesValidation.ColumnValuesToBeBetween(\n...         column=\"age\",\n...         min_value=18,\n...         max_value=65\n...     )\n... )\n&gt;&gt;&gt; key = \"ColumnValuesToBeBetween_age\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/ValuesValidation/column_values_to_be_between.py</code> <pre><code>class ColumnValuesToBeBetween(BaseValidation):\n    \"\"\"Check if the values in a column are between a range.\n\n    If the `min_value` or `max_value` is not provided then other will be used as the\n    threshold.\n\n    If neither `min_value` nor `max_value` is provided, then the validation will result\n    in failure.\n\n\n    Args:\n        column (str): Column to validate.\n        min_value (float | None): Minimum value for a column entry length.\n        max_value (float | None): Maximum value for a column entry length.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of validation.\n            Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate numeric range\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"age\": [25, 30, 42, 18, 65]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .ValuesValidation.ColumnValuesToBeBetween(\n        ...         column=\"age\",\n        ...         min_value=18,\n        ...         max_value=65\n        ...     )\n        ... )\n        &gt;&gt;&gt; key = \"ColumnValuesToBeBetween_age\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        column: str,\n        min_value: float | None = None,\n        max_value: float | None = None,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        min_max_arg_check(min_value, max_value)\n\n        super().__init__(column, impact, threshold, **kwargs)\n        self.min_value = min_value\n        self.max_value = max_value\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        return (\n            f\"The column '{self.column}' has values that are not \"\n            f\"between {self.min_value} and {self.max_value}.\"\n        )\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Check if the values in a column are between a range.\"\"\"\n        return (\n            min_max_filter(\n                frame,\n                f\"{self.column}\",\n                self.min_value,\n                self.max_value,\n            )\n            .group_by(self.column)\n            .agg(\n                nw.col(self.column).count().alias(f\"{self.column}-count\"),\n            )\n        )\n</code></pre>"},{"location":"validation_catalogue/Value%20Validation.html#validation_catalogue.ValuesValidation.ColumnsSumToBeBetween","title":"ColumnsSumToBeBetween","text":"<p>Check if the sum of columns is greater than or equal to <code>max_sum</code>.</p> <p>If the <code>min_value</code> or <code>max_value</code> is not provided then other will be used as the threshold.</p> <p>If neither <code>min_value</code> nor <code>max_value</code> is provided, then the validation will result in failure.</p> <p>Parameters:</p> Name Type Description Default <code>columns_list</code> <code>list[str]</code> <p>List of columns to sum.</p> required <code>min_sum_value</code> <code>float | None</code> <p>Minimum sum value that columns should be greater than or equal to.</p> <code>None</code> <code>max_sum_value</code> <code>float | None</code> <p>Maximum sum value that columns should be less than or equal to.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate macronutrient sum in range\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"protein\": [26],\n...     \"fat\": [19],\n...     \"carbs\": [0]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .ValuesValidation.ColumnsSumToBeBetween(\n...         columns_list=[\"protein\", \"fat\", \"carbs\"],\n...         min_sum_value=30,\n...         max_sum_value=50\n...     )\n... )\n&gt;&gt;&gt; key = \"ColumnsSumToBeBetween_protein-fat-carbs-combined\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/ValuesValidation/columns_sum_to_be_between.py</code> <pre><code>class ColumnsSumToBeBetween(BaseValidation):\n    \"\"\"Check if the sum of columns is greater than or equal to `max_sum`.\n\n    If the `min_value` or `max_value` is not provided then other will be used as the\n    threshold.\n\n    If neither `min_value` nor `max_value` is provided, then the validation will result\n    in failure.\n\n    Args:\n        columns_list (list[str]): List of columns to sum.\n        min_sum_value (float | None): Minimum sum value that columns should be greater\n            than or equal to.\n        max_sum_value (float | None): Maximum sum value that columns should be less than\n            or equal to.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of validation.\n            Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate macronutrient sum in range\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"protein\": [26],\n        ...     \"fat\": [19],\n        ...     \"carbs\": [0]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .ValuesValidation.ColumnsSumToBeBetween(\n        ...         columns_list=[\"protein\", \"fat\", \"carbs\"],\n        ...         min_sum_value=30,\n        ...         max_sum_value=50\n        ...     )\n        ... )\n        &gt;&gt;&gt; key = \"ColumnsSumToBeBetween_protein-fat-carbs-combined\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        columns_list: list[str],\n        min_sum_value: float | None = None,\n        max_sum_value: float | None = None,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        min_max_arg_check(min_sum_value, max_sum_value)\n\n        self.columns_list = columns_list\n        self.max_sum_value = max_sum_value\n        self.min_sum_value = min_sum_value\n        self.column = \"-\".join(self.columns_list) + \"-combined\"\n        super().__init__(self.column, impact, threshold, **kwargs)\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        return (\n            f\"The columns {self.columns_list} are not between {self.min_sum_value} and \"\n            f\"{self.max_sum_value}.\"\n        )\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Check if the sum of columns is greater than or equal to `max_sum`.\"\"\"\n        # This is just in case if there is some weird column name, such as \"sum\"\n        col_name = \"-\".join(self.columns_list) + \"-sum\"\n        summed_frame = frame.select(self.columns_list).with_columns(\n            nw.sum_horizontal(self.columns_list).alias(col_name),\n        )\n\n        return (\n            min_max_filter(\n                summed_frame,\n                col_name,\n                self.min_sum_value,\n                self.max_sum_value,\n            )\n            .with_columns(\n                nw.concat_str(\n                    [nw.col(column) for column in self.columns_list],\n                    separator=\" - \",\n                ).alias(\n                    self.column,\n                ),\n            )\n            .group_by(\n                self.column,\n            )\n            .agg(\n                nw.col(self.column).count().alias(f\"{self.column}-count\"),\n            )\n        )\n</code></pre>"},{"location":"validation_catalogue/Value%20Validation.html#validation_catalogue.ValuesValidation.ColumnsSumToBeEqualTo","title":"ColumnsSumToBeEqualTo","text":"<p>Check if the sum of the columns is equal to a specific value.</p> <p>Parameters:</p> Name Type Description Default <code>columns_list</code> <code>list[str]</code> <p>List of columns to sum.</p> required <code>sum_value</code> <code>float</code> <p>Value that the columns should sum to.</p> required <code>threshold</code> <code>float</code> <p>Threshold for validation. Defaults to 0.0.</p> <code>0.0</code> <code>impact</code> <code>Literal['low', 'medium', 'high']</code> <p>Impact level of validation. Defaults to \"low\".</p> <code>'low'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from validoopsie import Validate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate component sum equals total\n&gt;&gt;&gt; df = pd.DataFrame({\n...     \"hardware\": [5000],\n...     \"software\": [3000],\n...     \"personnel\": [12000],\n...     \"total\": [20000]\n... })\n&gt;&gt;&gt;\n&gt;&gt;&gt; vd = (\n...     Validate(df)\n...     .ValuesValidation.ColumnsSumToBeEqualTo(\n...         columns_list=[\"hardware\", \"software\", \"personnel\"],\n...         sum_value=20000\n...     )\n... )\n&gt;&gt;&gt; key = \"ColumnsSumToBeEqualTo_hardware-software-personnel-combined\"\n&gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n'Success'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # When calling validate on successful validation there is no error.\n&gt;&gt;&gt; vd.validate()\n</code></pre> Source code in <code>validoopsie/validation_catalogue/ValuesValidation/columns_sum_to_be_equal_to.py</code> <pre><code>class ColumnsSumToBeEqualTo(BaseValidation):\n    \"\"\"Check if the sum of the columns is equal to a specific value.\n\n    Args:\n        columns_list (list[str]): List of columns to sum.\n        sum_value (float): Value that the columns should sum to.\n        threshold (float, optional): Threshold for validation. Defaults to 0.0.\n        impact (Literal[\"low\", \"medium\", \"high\"], optional): Impact level of validation.\n            Defaults to \"low\".\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from validoopsie import Validate\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Validate component sum equals total\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     \"hardware\": [5000],\n        ...     \"software\": [3000],\n        ...     \"personnel\": [12000],\n        ...     \"total\": [20000]\n        ... })\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vd = (\n        ...     Validate(df)\n        ...     .ValuesValidation.ColumnsSumToBeEqualTo(\n        ...         columns_list=[\"hardware\", \"software\", \"personnel\"],\n        ...         sum_value=20000\n        ...     )\n        ... )\n        &gt;&gt;&gt; key = \"ColumnsSumToBeEqualTo_hardware-software-personnel-combined\"\n        &gt;&gt;&gt; vd.results[key][\"result\"][\"status\"]\n        'Success'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # When calling validate on successful validation there is no error.\n        &gt;&gt;&gt; vd.validate()\n    \"\"\"\n\n    def __init__(\n        self,\n        columns_list: list[str],\n        sum_value: float,\n        impact: Literal[\"low\", \"medium\", \"high\"] = \"low\",\n        threshold: float = 0.00,\n        **kwargs: KwargsParams,\n    ) -&gt; None:\n        self.columns_list = columns_list\n        self.sum_value = sum_value\n        self.column = \"-\".join(self.columns_list) + \"-combined\"\n        super().__init__(self.column, impact, threshold, **kwargs)\n\n    @property\n    def fail_message(self) -&gt; str:\n        \"\"\"Return the fail message, that will be used in the report.\"\"\"\n        return f\"The columns {self.columns_list} do not sum to {self.sum_value}.\"\n\n    def __call__(self, frame: Frame) -&gt; Frame:\n        \"\"\"Check if the sum of the columns is equal to a specific value.\"\"\"\n        # This is just in case if there is some weird column name, such as \"sum\"\n        col_name = \"-\".join(self.columns_list) + \"-sum\"\n        return (\n            frame.select(self.columns_list)\n            .with_columns(\n                nw.sum_horizontal(self.columns_list).alias(col_name),\n            )\n            .filter(\n                nw.col(col_name) != self.sum_value,\n            )\n            .with_columns(\n                nw.concat_str(\n                    [nw.col(column) for column in self.columns_list],\n                    separator=\" - \",\n                ).alias(\n                    self.column,\n                ),\n            )\n            .group_by(\n                self.column,\n            )\n            .agg(\n                nw.col(self.column).count().alias(f\"{self.column}-count\"),\n            )\n        )\n</code></pre>"}]}